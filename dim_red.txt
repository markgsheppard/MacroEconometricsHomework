/* Predict stock returns using dimension reduction methods *//* Original author: Professor Aaron Smith */new;library pgraph;chdir c:\gauss21\dr\;                /*  you will need to change this  */output file=factor1.out reset;/**********************************//*        Prepare Data            *//**********************************/start=195903;finish=199812;/* Variables in BM:  Date followed by 10 portfolios sorted by deciles of book-to-market value  (see http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html) */loadm BMdata[]=BM.txt;BMdata=reshape(BMdata,rows(BMdata)/11,11);BMdata=selif(BMdata,(BMdata[.,1].>=start).*(BMdata[.,1].<=finish));/*  This file contains date, Rm-Rf, SMB, HML, Rf */loadm fac[]=FF_factors.txt;fac = reshape(fac,rows(fac)/5,5);dates=fac[.,1];fac=selif(fac,(fac[.,1].>=start).*(fac[.,1].<=finish));mkt=fac[.,2];    /*  excess returns on market portfolio */smb=fac[.,3];    /*  small minus big, i.e., returns on portfolio long on small, short on large stocks */BM=fac[.,4];     /*  high EP minus low EP, i.e., returns on portfolio long on value, short on growth stocks */rtb=fac[.,5];    /*  one month T-Bill return  *//*  This file contains date, Aaa yield, Baa yield, Div/Price ratio */loadm other[]=other_monthly.txt;other = reshape(other,rows(other)/4,4);other=selif(other,(dates.>=start).*(dates.<=finish));def=100*(other[.,2]-other[.,3]);dpr=100*other[.,4];rtb=fac[.,5];     /*  one month T-Bill return  */vwr=mkt;/* Create BM portfolios  */bm1=BMdata[.,2]-fac[.,5];   /* 1st decile BM portfolio excess return */bm2=BMdata[.,3]-fac[.,5];   /* 2nd decile BM portfolio excess return */bm3=BMdata[.,4]-fac[.,5];   /* 3rd decile BM portfolio excess return */bm4=BMdata[.,5]-fac[.,5];   /* 4th decile BM portfolio excess return */bm5=BMdata[.,6]-fac[.,5];   /* 5th decile BM portfolio excess return */bm6=BMdata[.,7]-fac[.,5];   /* 6th decile BM portfolio excess return */bm7=BMdata[.,8]-fac[.,5];   /* 7th decile BM portfolio excess return */bm8=BMdata[.,9]-fac[.,5];   /* 8th decile BM portfolio excess return */bm9=BMdata[.,10]-fac[.,5];  /* 9th decile BM portfolio excess return */bm10=BMdata[.,11]-fac[.,5]; /* 10th decile BM portfolio excess return */load m_data[480,146] = macro_data.txt; /* Data Span:  1959:1 to 1998:12 */X = m_data[3:480,.];   /* Remove first 2 obs because some variables have missing values due to them being second differences of original data  *//* Choose X-variables */choose=1  |      @ IP: Industrial production: total index @       21 |      @ LHUR: Unemployment rate: all workers, 16 years and over @       27 |      @ LPNAG: Employees on non-agriculture: total @       50 |      @ MSMTQ: Manufacturing and Trade: total @       57 |      @ RTQ: Retail Trade: total @       133|      @ GMCQ: Personal consumption expend (Chained)-total @       43 |      @ HSFR: Housing starts @       59 |      @ IVMTQ: Manufacturing and trade inventories @       65 |      @ IVSRQ: Ratio for mfg and trade: inventory/sales @       73 |      @ PMNV: Napm inventories index @       76 |      @ MOCMQ: new orders (net)-consumer goods and materials @       79 |      @ MO: Mfg new orders: all manufacturing industries, total @         97 |      @ FSNCOM: NYSE common stock price index: composite @       109|      @ EXRUS: US effective exchange rate @        105|      @ FYGT10: Interest rate: US treasury const maturities, 10-yr. @       107|      @ FYBAAC: Bond yield: moody's baa corporate @       143|      @ SFYGT10: Spread fygt10-fyff @             90 |      @ FM1: Money stock: m1 @       93 |      @ FM2DQ: Money supply @         118|      @ PUNEW: CPI-u: all items @       123|      @ PUCD: CPI-u: durables @       128|      @ GMDC: PCE, impl pr deft: pce @       42 |      @ LEHM: Average hr earnings of prod. workers: manufacturing @       114;      @ HHSNTN: U. of mich. index of consumer expectations @  /* choose=seqa(1,1,146);   */               /* This is to choose all 146 variables *//*************************************************************//*           Designate y and x variables                     *//*************************************************************/x=x[.,choose];y=bm5;T=rows(y);/*************************************************************//*       Ordinary Least Squares                               *//*************************************************************/format /rzs 10,5;XX=ones(T,1)~X;b=inv(XX'XX)*XX'y;K=cols(XX);e=y-XX*b;sig2=e'e/T;aicc=T*ln(sig2)+2*(K+1)*T/(T-K-2);call ols(0,y,x);""; "Ordinary Least Squares Results";"# variables = " K-1;"R2 =" 1-e'e/((y-meanc(y))'(y-meanc(y)));"AICC = " aicc;/*************************************************************//*        Principal Components                               *//*************************************************************/              /* OPEN COMMENT FOR PC *//* Create matrix to decompose  */   omega=X'X/T;              /* cross-product matrix (same as Gauss "princomp" command) */    /*omega=vcx(X);  */             /* variance-covariance matrix */    /*omega=corrx(X);*/      /* correlation matrix         *//* eigenvalue decomposition (reorder into descending order)  */{va,ve}=eigrs2(omega);va=rev(va);  ve=rev(ve')';/* plot eigenvalues */xy(seqa(1,1,cols(X)),va);/* call procedure to determine number of PCR factors by CV */  s2=cv_pcr(y,x);     q=minindc(s2);   /*q=5; */                                    /* you can choose the number of PCA factors here *//* create factors  */facs=X*ve[.,1:q];XX=ones(T,1)~facs[.,1:q];b=inv(XX'XX)*XX'y;e=y-XX*b;sig2=e'e/T;  K=q+1;                                  /* Add 1 to account for intercept */  aicc=T*ln(sig2)+2*(K+1)*T/(T-K-2);""; "Principal Components Regression Results";"# facs = " q;"MSFE = " s2[q];       /* mean square prediction error from CV */"R2 =" 1-e'e/((y-meanc(y))'(y-meanc(y)));"AICC = " aicc;            /* CLOSE COMMENT FOR PC */  /*************************************************************//*        Sliced Inverse Regression                          *//*************************************************************/             /* OPEN COMMENT FOR SIR */h = 10;{beta_sir,se,va_sir,stat,crit,num_fact}=sir(y,x,h);     /*  call SIR proc  *//* Print some output  */""; "SIR"; "Chi-square Test for Number of Factors: ";format /rzs 12,5;"        Number    Statistic     Critical Value"seqa(1,1,rows(stat))~stat~crit;""; "# of factors = " num_fact;/* calculate SIR factors */z1=x*beta_sir[.,1];z2=x*beta_sir[.,2];/*  Plot y against first 2 SIR factors  */_plctrl=-1;       /*  -1 for no line in scatter plot */begwind;     window(1,2,0);  setwind(1);   xy(z1,y);  setwind(2);   xy(z2,y);endwind;/* use 1st SIR factor */XX=ones(T,1)~z1;b=inv(XX'XX)*XX'y;e=y-XX*b;sig2=e'e/T;  K=q+1;                                  /* Add 1 to account for intercept */  aicc=T*ln(sig2)+2*(K+1)*T/(T-K-2);""; "Sliced Inverse Regression Results";"# facs = " 1;"R2 =" 1-e'e/((y-meanc(y))'(y-meanc(y)));"AICC = " aicc;                /* CLOSE COMMENT FOR SIR */            /*************************************************************//*      CV Procedure for PCR                                 *//*                                                           *//*        Inputs:  y - dependent variable                    *//*                 x - explanatory variables                 *//*        Output:  s2 - mean squared prediction error        *//*************************************************************/proc(1)=cv_pcr(y,x);local ry,cx,ehat,ii,cou,yy,xx,xx1,q,s2,facs,va,ve,omega;ry=rows(y);cx=cols(X);ehat=zeros(ry,cx);cou=seqa(1,1,ry);ii=1;do while ii le ry;  yy=delif(y,cou.==ii);  xx=delif(x,cou.==ii);  omega=corrx(xx);          /* correlation matrix         */  {va,ve}=eigrs2(omega);  ve=rev(ve')';  /* eigenvalue decomposition (reorder into descending order)  */  facs=xx*ve;  q=1;  do while q le cx;    XX1=ones(ry-1,1)~facs[.,1:q];    b=inv(XX1'XX1)*XX1'yy;    ehat[ii,q]=y[ii]-b[1]-x[ii,.]*ve[.,1:q]*b[2:q+1];  q=q+1;  endo;ii=ii+1;endo;s2=diag(ehat'ehat/ry);retp(s2);endp;/*********************  CV_PCR Ends **********************//*************************************************************//*      Sliced Inverse Regression Procedure                  *//*                                                           *//*        Inputs:  y - dependent variable                    *//*                 x - independent variables                 *//*                 h - number of slices                      *//*************************************************************/proc(6) = sir(y,x,h);local ry,cx,mat,ys,xs,xbar,xsd,sig_xx,a,xtilde,	dum,m,wt,ii,sig_eta,va,ve,inv_sig_half,eta,beta_sir,cov,lam,se,	q,low_one,stat1,stat,df,crit,ee,num_fact;ry=rows(y);		cx=cols(x);		mat=sortc(y~x,1);		@ sort y-x data on y-variable, an ascending order @ys=mat[.,1];		    @ the sorted y @xs=mat[.,2:(cx+1)];	@ the sorted x-variables @/* Step 1: Standardize x by an affine transformation */xbar=meanc(xs);    @ mean of x's @xsd=stdc(xs);      @ standard deviation of x's @sig_xx=vcx(xs);	   @ variance-covariance matrix of x's @	a=chol(sig_xx)';		  @lower triangular cholesky decomposition @inv_sig_half=inv(a);xtilde=inv_sig_half*(xs-xbar')';	@ affine transformation of x's @	xtilde=xtilde';/* Step 2: Divide range of y into h slices. Let the proportion of yi that falls in each slice be 1/h.  */dum=dummy(ys,quantile(y,seqa(1/h,1/h,h-1)));   @ y dummies @/* Step 3: Within each slice, compute the sample mean of xtilde */m=inv(dum'dum)*dum'xtilde;   @ sample mean of xtilde in each slice @/* Step 4: conduct a weighted principal component analysis */wt=sumc(dum)/ry;    @ weights for each slice @sig_eta=(wt.*m)'m;        @  covariance matrix of weighted average x given y @{va,ve}=eigrs2(sig_eta);	 @ Gauss reports eigenvalues in an ascending order. @/* Step 5: retransform back to the original scale */eta=(rev(ve'))';    @ reverse the order of the rows in a matrix @beta_sir=inv_sig_half'*eta;	cov=inv(sig_xx)/ry;lam=rev((1-va)./va);se=sqrt(diag(cov)*lam');@ testing number of factors @q=seqa(0,1,cx);low_one=lowmat(ones(cx,cx));stat1=ry*low_one*va;stat=rev(stat1);df=(cx-q).*(h-q-1);crit=cdfchii(0.95,df);   ee=stat.>crit;	@ indicate reject: Yes or No @num_fact=sumc(ee);  retp(beta_sir,se,rev(va),stat,crit,num_fact);endp;/*********************  SIR Ends **********************/"";